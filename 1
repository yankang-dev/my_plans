5.2.21	第k个排列（*）
时间限制：1秒 | 内存限制：262144K | 语言限制：不限
给定参数n，从1到n会有n个整数：1,2,3,…,n，这n个数字共有 n! 种排列。
按大小顺序升序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：
"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列
参考代码（Python）：
def _getList(lst, line, ret):
        if not lst:
        ret.append(line)
        return

        for idx, v in enumerate(lst):
        tmp = lst[:]
        tmp.pop(idx)
        l = line[:]
        l.append(v)
        _getList(tmp, l, ret)

        def getNum(n, k):
        lst = range(1,n+1)
        ret = []
        _getList(lst, [], ret)
        if k >= len(ret):
        return -1
        lst = ret[k-1]
        sLst = []
        for v in lst:
        sLst.append(str(v))
        return "".join(sLst)

        if __name__ == '__main__':
        n = int(raw_input())
        k = int(raw_input())
        v = getNum(n, k)
        print(v)
5.2.22	报数游戏（*）
时间限制：1秒 | 内存限制：262144K | 语言限制：不限
100个人围成一圈，每个人有一个编码，编号从1开始到100。他们从1开始依次报数，报到为M的人自动退出圈圈，然后下一个人接着从1开始报数，直到剩余的人数小于M。请问最后剩余的人在原先的编号为多少？
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;
import java.util.Scanner;
import java.util.stream.Collectors;

public class Main {
    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        int m=scanner.nextInt();
        if(m<=1||m>=100){
            System.out.println("ERROR!");
            return;
        }
        List<Integer> list=new ArrayList<>();
        for(int i=1;i<=100;i++){
            list.add(i);
        }
        int num;
        int flag=0;
        while (list.size()>=m){
            ListIterator<Integer> it= list.listIterator();
            while (it.hasNext()){
                num=it.next();
                flag++;
                if(flag==m){
                    it.remove();
                    flag=0;
                }
            }
        }
        List<Integer> letters=list.subList(0, m-1);
        List<String> listStrings=letters.stream().map(v->v.toString()).collect(Collectors.toList());
        String lettersCom=String.join(",",listStrings);
        System.out.println(lettersCom);
    }
}
5.2.23	水仙花数（*）
时间限制：1秒 | 内存限制：262144K | 语言限制：不限
所谓水仙花数，是指一个n位的正整数，其各位数字的n次方和等于该数本身。例如153是水仙花数，153是一个3位数，并且153 = 1^3 + 5^3 + 3^3。
参考代码（Java）：
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int result = 0;
            int m,n;
            try{
                n = sc.nextInt();
                m = sc.nextInt();
                if(3<=n&&n<=7&&m>=0){
                    result = getShui(n, m);
                }else{
                    result = -1;
                }
            }catch(Exception e){
                result = -1;
            }
            System.out.println(result);
        }
        sc.close();

    }
    public static int getShui(int n, int m){
        int end = 0;
        List<Integer> list = new ArrayList<Integer>();
        int max = getMax(n);
        int min = getMin(n);
        for(int i=min; i<=max; i++){
            String str = i+"";
            int result = 0;
            for (int j = 0; j < str.length(); j++) {
                int num = str.charAt(j)-48;
                result += (int)Math.pow(num, n);
            }
            if(i==result){
                list.add(i);
            }
        }
        if(m>list.size()-1){
            end = m*list.get(list.size()-1);
        }else{
            end = list.get(m);
        }
        return end;
    }
    private static int getMax(int n){
        String str = "";
        for(int i=0; i<n; i++){
            str = str+9;
        }
        return Integer.parseInt(str);
    }
    private static int getMin(int n){
        String str = "1";
        for(int i=1; i<n; i++){
            str = str+0;
        }
        return Integer.parseInt(str);
    }
}
5.2.24	火星文计算（*）
时间限制：1秒 | 内存限制：262144K | 语言限制：不限
已知火星人使用的运算符为#、$，其与地球人的等价公式如下： 
x#y = 2*x+3*y+4 
x$y = 3*x+y+2 
1、其中x、y是无符号整数 
2、地球人公式按C语言规则计算 
3、火星人公式中，$的优先级高于#，相同的运算符，按从左到右的顺序计算 
现有一段火星人的字符串报文，请你来翻译并计算结果。
参考代码（Python）：
import sys
origin_str = sys.stdin.readline().strip()
        stack = list()
        pre_op = "#"
        num = 0
        for index, each in enumerate(origin_str):
        if each.isdigit():
        num = 10 * num + int(each)
        if index == len(origin_str) - 1 or each in "#$":
        if pre_op == "#":
        stack.append(num)
        elif pre_op == "$":
        value = stack.pop() * 3 + num + 2
        stack.append(value)
        pre_op = each
        num = 0
        pre = stack.pop(0)
        while stack:
        next = stack.pop(0)
        pre = pre * 2 + next * 3 + 4
        print(pre)
5.2.25	字符串加密（*）
时间限制：2秒 | 内存限制：65536K | 语言限制：不限
给你一串未加密的字符串str，通过对字符串的每一个字母进行改变来实现加密，加密方式是在每一个字母str[i]偏移特定数组元素a[i]的量，数组a前三位已经赋值：a[0]=1,a[1]=2,a[2]=4。当i>=3时，数组元素a[i]=a[i-1]+a[i-2]+a[i-3]，
例如：原文 abcde 加密后 bdgkr，其中偏移量分别是1,2,4,7,13。
参考代码（JS）：
while(line = readline()){
        var total = parseInt(line)
        for(var count = 0; count < total; count ++){
        var raw = readline()
        var encript = ''
        for(var i = 0;i<raw.length;i++){
        var charNum = raw[i].charCodeAt()
        var code = (charNum + getOffset(i)%26)
        if(code >= (97+26)){
        code = code - 26
        }
        encript +=String.fromCharCode(code)
        }
        print(encript)
        }
        }
        function getOffset(i){
        if(i<30){
        var pre = [1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890,66012,121415,223317,410744,755476,1389537,2555757,4700770,8646064,15902591,29249425,53798080]
        return pre[i]
        }else {
        return getOffset(i-1)+getOffset(i-2)+getOffset(i-3)
        }
        }
5.2.26	最远足迹（*）
时间限制：1秒 | 内存限制：32768K | 语言限制：不限
某探险队负责对地下洞穴进行探险。探险队成员在进行探险任务时，随身携带的记录器会不定期地记录自身的坐标，但在记录的间隙中也会记录其他数据。探索工作结束后，探险队需要获取到某成员在探险过程中相对于探险队总部的最远的足迹位置。
1. 仪器记录坐标时，坐标的数据格式为(x,y)，如(1,2)、(100,200)，其中0<x<1000，0<y<1000。同时存在非法坐标，如(01,1)、(1,01)，(0,100)属于非法坐标。
2. 设定探险队总部的坐标为(0,0)，某位置相对总部的距离为：x*x+y*y。
3. 若两个座标的相对总部的距离相同，则第一次到达的坐标为最远的足迹。
4. 若记录仪中的坐标都不合法，输出总部坐标（0,0）。
备注：不需要考虑双层括号嵌套的情况，比如sfsdfsd((1,2))。
5.2.27	删除字符串中字符最少字符（*）
时间限制：1秒 | 内存限制：262144K | 语言限制：不限
删除字符串中出现次数最少的字符，如果有多个字符出现次数一样，则都删除。
def test(s):
        l=list(s)
        temp=dict()
        for i in l:
        if i not in temp:
        temp[i]=1
        else:
        temp[i]+=1
        min_=len(s)
        for times in temp.values():
        min_=min(min_,times)
        chars=set()
        for char,time in temp.items():
        if time==min_:
        chars.add(char)
        for i in chars:
        for j in range(min_):
        l.remove(i)
        return "empty" if len(l)==0 else "".join(l)

        s=input()
        print(test(s))
5.2.28	求字符串中所有整数的最小和（*）
时间限制：1秒 | 内存限制：262144K | 语言限制：不限
输入字符串s，输出s中包含所有整数的最小和
说明
1. 字符串s，只包含 a-z A-Z +- ；
2. 合法的整数包括
    1） 正整数 一个或者多个0-9组成，如 0 2 3 002 102
    2）负整数 负号 - 开头，数字部分由一个或者多个0-9组成，如 -0 -012 -23 -00023
参考代码（Java）：
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String strIn = in.nextLine();
        int result = 0;
        boolean readingNegative = false;
        StringBuilder negativeNum = new StringBuilder();
        int positiveNum = 0;
        for(char c : strIn.toCharArray()){
            if (c >= '0' && c <= '9'){
                if (readingNegative)
                    negativeNum.append(c);
                else {
                    positiveNum = c - '0';
                    result += positiveNum;
                    readingNegative = false;
                }
            } else if (c == '-'){
                readingNegative = true;
                if (!"".equals(negativeNum.toString())){
                    result-=Integer.parseInt(negativeNum.toString());
                    negativeNum = new StringBuilder();// 重新初始化
                }
            } else {
                if (!"".equals(negativeNum.toString())){
                    result-=Integer.parseInt(negativeNum.toString());
                    negativeNum = new StringBuilder();// 重新初始化
                }
                readingNegative = false;
            }
        }
        System.out.println(result);
    }
}
5.2.29	数列描述（*）
时间限制：1秒 | 内存限制：32768K | 语言限制：不限
有一个数列a[N] (N=60)，从a[0]开始，每一项都是一个数字。数列中a[n+1]都是a[n]的描述。其中a[0]=1。

规则如下：

a[0]:1

a[1]:11(含义：其前一项a[0]=1是1个1，即“11”。表示a[0]从左到右，连续出现了1次“1”）

a[2]:21(含义：其前一项a[1]=11，从左到右：是由两个1组成，即“21”。表示a[1]从左到右，连续出现了两次“1”)

a[3]:1211(含义：其前一项a[2]=21，从左到右：是由一个2和一个1组成，即“1211”。表示a[2]从左到右，连续出现了1次“2”，然后又连续出现了1次“1”)

a[4]:111221(含义：其前一项a[3]=1211，从左到右：是由一个1、一个2、两个1组成，即“111221”。表示a[3]从左到右，连续出现了1次“1”，连续出现了1次“2”，连续出现了两次“1”)

请输出这个数列的第n项结果（a[n]，0≤n≤59）。
参考代码（Java）：
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while(in.hasNext()) {
            int n = in.nextInt();
            String[] num = new String[n + 1];
            num[0] = "1";
            num[1] = "11";
            num[2] = "21";
            num[3] = "1211";
            num[4] = "111221";
            for (int i = 5; i <= n; i++) {
                String tmp = num[i-1]; // 前一个
                char[] arr = tmp.toCharArray();
                StringBuffer sb = new StringBuffer();
                int t = 0;
                char before = arr[0];
                for (char c : arr){
                    if (c == before){
                        t++;
                    }
                    else{
                        sb.append(t).append(before);
                        before = c;
                        t = 1;
                    }
                }
                sb.append(t).append(before); // 最后
                num[i] = sb.toString();
            }

            System.out.println(num[n]);
        }
    }
}
5.2.30	寻找相同子串（*）
时间限制：1秒 | 内存限制：65536K | 语言限制：不限
给你两个字符串 t 和 p ，要求从 t 中找到一个和 p 相同的连续子串，并输出该字串第一个字符的下标。
参考代码（Java）：
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String line1 = sc.nextLine();
        String line2 = sc.nextLine();
        int result = line1.indexOf(line2);
        if (result == -1) {
            System.out.println("No");
        } else {
            System.out.println(result + 1);
        }
    }
}
5.2.31	执行时长（*）
时间限制：1秒 | 内存限制：262144K | 语言限制：不限
为了充分发挥GPU算力，需要尽可能多的将任务交给GPU执行，现在有一个任务数组，数组元素表示在这1秒内新增的任务个数且每秒都有新增任务，假设GPU最多一次执行n个任务，一次执行耗时1秒，在保证GPU不空闲情况下，最少需要多长时间执行完成
输入描述:
第一个参数为GPU一次最多执行的任务个数，取值范围[1, 10000]
第二个参数为任务数组长度，取值范围[1, 10000]
第三个参数为任务数组，数字范围[1, 10000]

输出描述:
执行完所有任务最少需要多少秒
示例1
输入
3
5
1 2 3 4 5
输出
6
说明
一次最多执行3个任务，最少耗时6s
参考代码（Java）：
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int step = Integer.parseInt(sc.nextLine());
        int length = Integer.parseInt(sc.nextLine());
        String s =  sc.nextLine();

        List<Integer> alist = new ArrayList<>();
        String[] split = s.replaceAll(" ","").split("");
        for (int i = 0; i < split.length; i++) {
            if(null != split[i]){
                alist.add(Integer.parseInt(split[i]));
            }
        }

        int res = 0;
        int count = 0;
        for (int i = 0; i < length; i++) {
            if(step>=(alist.get(i)+res)){
                res =0;
            }else{
                int temp = alist.get(i)+res;
                res = temp -step;
            }
            count++;
        }
        if(res >0){
            int snum =  step%res;
            int con = res/step;
            if(snum>0){
                count = count +con+1;
            }else{
                count = count+con;
            }
        }
        System.out.println(count);

    }
}
5.2.32	找朋友（*）
时间限制：1秒 | 内存限制：262144K | 语言限制：不限
在学校中，N个小朋友站成一队， 第i个小朋友的身高为height[i]，
第i个小朋友可以看到的第一个比自己身高更高的小朋友j，那么j是i的好朋友(要求j > i)。
请重新生成一个列表，对应位置的输出是每个小朋友的好朋友位置，如果没有看到好朋友，请在该位置用0代替。
小朋友人数范围是 [0, 40000]。
输入描述:
第一行输入N，N表示有N个小朋友
第二行输入N个小朋友的身高height[i]，都是整数
输出描述:
输出N个小朋友的好朋友的位置
示例1
输入
2
100 95
输出
0 0
说明
第一个小朋友身高100，站在队尾位置，向队首看，没有比他身高高的小朋友，所以输出第一个值为0。
第二个小朋友站在队首，前面也没有比他身高高的小朋友，所以输出第二个值为0。
参考代码（Java）：
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] height = new int[n];
        int[] result = new int[n];
        for(int i=0;i<n;i++){
            height[i] =  sc.nextInt();
        }
        boolean flag = false;
        for(int i=0;i<height.length;i++){
            for(int j=i+1;j<height.length;j++){
                if(height[j]>height[i]){
                    result[i]=j;
                    flag = true;
                    break;
                }
            }
            if(!flag){
                result[i]=0;
                flag=false;
            }

        }

        for(int i=0;i<result.length;i++){
            System.out.print(result[i]+" ");
        }
    }
}

